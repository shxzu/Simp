package cc.simp.modules.impl.exploit;

import cc.simp.Simp;
import cc.simp.event.impl.player.MotionEvent;
import cc.simp.event.impl.player.StrafeEvent;
import cc.simp.event.impl.world.WorldLoadEvent;
import cc.simp.modules.Module;
import cc.simp.modules.ModuleCategory;
import cc.simp.modules.ModuleInfo;
import cc.simp.modules.impl.player.ScaffoldModule;
import cc.simp.property.Property;
import cc.simp.property.impl.DoubleProperty;
import cc.simp.property.impl.EnumProperty;
import cc.simp.utils.Timer;
import cc.simp.utils.mc.InventoryUtils;
import cc.simp.utils.mc.MovementUtils;
import cc.simp.utils.mc.RaytraceUtils;
import io.github.nevalackin.homoBus.Listener;
import io.github.nevalackin.homoBus.annotations.EventLink;
import net.minecraft.block.Block;
import net.minecraft.block.BlockBed;
import net.minecraft.block.material.Material;
import net.minecraft.enchantment.Enchantment;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.init.Blocks;
import net.minecraft.item.ItemStack;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.potion.Potion;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.Vec3;

import java.util.HashMap;
import java.util.Map;

import static cc.simp.utils.Util.mc;

@ModuleInfo(label = "Bed Destroyer", category = ModuleCategory.EXPLOIT)
public class BedDestroyerModule extends Module {

    // W.I.P -shxzu

    public EnumProperty<Mode> modeProperty = new EnumProperty<>("Mode", Mode.SIMPLE);
    public DoubleProperty rangeProperty = new DoubleProperty("Range To Destroy", 4.5, 3, 5, 0.1);

    private final Map<BlockPos, Double> currentProgressMap = new HashMap<>();

    private enum Mode {
        SIMPLE,
    }

    public BedDestroyerModule() {
        setSuffixListener(modeProperty);
    }

    @EventLink
    private final Listener<MotionEvent> motionEventListener = event -> {
        if (modeProperty.getValue() == Mode.SIMPLE) {
            int rangeValue = rangeProperty.getValue().intValue();
            BlockPos playerPos = new BlockPos(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ);

            BlockPos targetPos = null;
            EnumFacing targetFacing = null;
            double closestDistance = (rangeValue + 2) * (rangeValue + 2);

            for (int x = -rangeValue; x <= rangeValue; x++) {
                for (int y = -rangeValue; y <= rangeValue; y++) {
                    for (int z = -rangeValue; z <= rangeValue; z++) {
                        BlockPos currentPos = playerPos.add(x, y, z);
                        Block block = mc.theWorld.getBlockState(currentPos).getBlock();

                        if (block instanceof BlockBed) {
                            for (EnumFacing facing : EnumFacing.values()) {
                                BlockPos offsetPos = currentPos.offset(facing);
                                double distance = playerPos.distanceSq(offsetPos);

                                if (distance < closestDistance) {
                                    targetPos = currentPos;
                                    targetFacing = facing;
                                    closestDistance = distance;
                                }
                            }
                        }
                    }
                }
            }

            if (targetPos != null && targetFacing != null) {
                double currentProgress = currentProgressMap.getOrDefault(targetPos, 0.0);
                Block block = mc.theWorld.getBlockState(targetPos).getBlock();
                double blockHardness = getBlockHardness(block, mc.thePlayer.inventory.getCurrentItem(), false, true);
                double progressIncrement = blockHardness * 0.25;

                currentProgress += progressIncrement;

                if (currentProgress > blockHardness) {
                    currentProgress = blockHardness;
                }

                currentProgressMap.put(targetPos, currentProgress);

                Simp.INSTANCE.getRotationManager().rotateToward(Simp.INSTANCE.getRotationManager().getRotationsToBlock(targetPos, targetFacing)[0], Simp.INSTANCE.getRotationManager().getRotationsToBlock(targetPos, targetFacing)[1], 90.0f);
                swing();
                mc.playerController.onPlayerDamageBlock(targetPos, targetFacing);

                if (currentProgress >= blockHardness) {
                    mc.gameSettings.keyBindAttack.setPressed(false);
                    currentProgressMap.remove(targetPos);
                }
            }
        }
    };

    private void swing() {
        mc.thePlayer.swingItem();
    }

    public static float getBlockHardness(final Block block, final ItemStack itemStack, boolean ignoreSlow, boolean ignoreGround) {
        final float getBlockHardness = block.getBlockHardness(mc.theWorld, null);
        if (getBlockHardness < 0.0f) {
            return 0.0f;
        }
        return (block.getMaterial().isToolNotRequired() || (itemStack != null && itemStack.canHarvestBlock(block))) ? (getToolDigEfficiency(itemStack, block, ignoreSlow, ignoreGround) / getBlockHardness / 30.0f) : (getToolDigEfficiency(itemStack, block, ignoreSlow, ignoreGround) / getBlockHardness / 100.0f);
    }

    public static float getToolDigEfficiency(ItemStack itemStack, Block block, boolean ignoreSlow, boolean ignoreGround) {
        float n = (itemStack == null) ? 1.0f : itemStack.getItem().getStrVsBlock(itemStack, block);
        if (n > 1.0f) {
            final int getEnchantmentLevel = EnchantmentHelper.getEnchantmentLevel(Enchantment.efficiency.effectId, itemStack);
            if (getEnchantmentLevel > 0 && itemStack != null) {
                n += getEnchantmentLevel * getEnchantmentLevel + 1;
            }
        }
        if (mc.thePlayer.isPotionActive(Potion.digSpeed)) {
            n *= 1.0f + (mc.thePlayer.getActivePotionEffect(Potion.digSpeed).getAmplifier() + 1) * 0.2f;
        }
        if (!ignoreSlow) {
            if (mc.thePlayer.isPotionActive(Potion.digSlowdown)) {
                float n2;
                switch (mc.thePlayer.getActivePotionEffect(Potion.digSlowdown).getAmplifier()) {
                    case 0: {
                        n2 = 0.3f;
                        break;
                    }
                    case 1: {
                        n2 = 0.09f;
                        break;
                    }
                    case 2: {
                        n2 = 0.0027f;
                        break;
                    }
                    default: {
                        n2 = 8.1E-4f;
                        break;
                    }
                }
                n *= n2;
            }
            if (mc.thePlayer.isInsideOfMaterial(Material.water) && !EnchantmentHelper.getAquaAffinityModifier(mc.thePlayer)) {
                n /= 5.0f;
            }
            if (!mc.thePlayer.onGround && !ignoreGround) {
                n /= 5.0f;
            }
        }
        return n;
    }
}